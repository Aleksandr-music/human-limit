<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>System Interface</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="style.css">

  <style>
    :root{
      --banner: url("images/png/hl-system-layered-banner-01.png");

      /* IMPORTANT:
         do NOT override --dim from style.css (it is used as a color)
         use a dedicated variable for overlay alpha */
      --bg-dim-alpha: 0.04;

      /* Parallax state (updated by JS) */
      --mx: 0px;
      --my: 0px;
    }

    /* Disable global banner layers from style.css on this page */
    body::before,
    body::after{
      display:none !important;
      content:none !important;
    }

    html, body { height:100%; }

    body{
      margin:0;
      min-height:100svh;
      overflow:hidden;
    }

    /* Multi-layer background (one PNG, 3 depth layers) */
    .bg{
      position:fixed;
      inset:0;
      z-index:-2;
      overflow:hidden;
      background:#0b0b0b;
    }

    .bg-layer{
      position:absolute;
      inset:-3vh -3vw; /* prevents edges during motion */
      background-image: var(--banner);
      background-repeat:no-repeat;
      background-position:center center;
      background-size:cover;
      will-change:transform;
      transform: translate3d(0,0,0);
    }

    /* Add tiny scale differences so depth is visible even without moving the mouse */
    .bg-layer-1{
      opacity:1;
      transform: translate3d(calc(var(--mx) * 0.25), calc(var(--my) * 0.25), 0) scale(1.00);
    }

    .bg-layer-2{
      opacity:0.55;
      mix-blend-mode: screen;
      transform: translate3d(calc(var(--mx) * 0.55), calc(var(--my) * 0.55), 0) scale(1.01);
    }

    .bg-layer-3{
      opacity:0.25;
      mix-blend-mode: lighten;
      transform: translate3d(calc(var(--mx) * 0.9), calc(var(--my) * 0.9), 0) scale(1.02);
    }

    .bg-dim{
      position:absolute;
      inset:0;
      pointer-events:none;
      background: rgba(0,0,0,var(--bg-dim-alpha));
    }

    /* Mobile: keep stable, avoid jitter */
    @media (max-width: 680px){
      :root{ --bg-dim-alpha: 0.06; }

      .bg-layer{
        inset:0;
        background-size:cover;
      }

      /* on mobile we keep layers but without motion; scale still gives subtle depth */
      .bg-layer-1{ transform: scale(1.00); }
      .bg-layer-2{ transform: scale(1.01); }
      .bg-layer-3{ transform: scale(1.02); }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .bg-layer{
        transform: none !important;
      }
    }

    /* page-specific (system.html only) */
    .title{
      font-size:18px;
      margin-bottom:26px;
    }

    .menu .node{
      display:block;
      font-size:16px;
      line-height:30px;
    }

    .menu .node--service{
      margin-top:10px;
      font-size:14px;
      color:var(--dim);
    }
    .menu .node--service::before{ color:var(--dim); }
    .menu .node--service:hover{ color:var(--fg); }

    .status{
      margin-top:34px;
      font-size:13px;
    }

    .cmdline{
      margin-top:28px;
      font-size:14px;
    }

    #cmd{
      background:none;
      border:none;
      outline:none;
      color:var(--fg);
      font-family:"JetBrains Mono", monospace;
      font-size:14px;
      width:min(420px, 80vw);
    }

    .output{
      margin-top:18px;
      font-size:14px;
      color:var(--dim);
      min-height:18px;
      white-space:pre-line;
    }
  </style>
</head>

<body>

  <!-- Multi-layer parallax background -->
  <div class="bg" aria-hidden="true">
    <div class="bg-layer bg-layer-1"></div>
    <div class="bg-layer bg-layer-2"></div>
    <div class="bg-layer bg-layer-3"></div>
    <div class="bg-dim"></div>
  </div>

  <div class="title">HUMAN LIMIT â€” SYSTEM INTERFACE</div>

  <nav class="menu" aria-label="System nodes">
    <a class="node" href="world.html">WORLD</a>
    <a class="node" href="mechanics.html">SYSTEM</a>
    <a class="node" href="subjects.html">SUBJECTS</a>
    <a class="node" href="archive.html">ARCHIVE</a>

    <a class="node node--service" href="state.html">STATE MONITOR</a>
  </nav>

  <div class="status dim">
    ACCESS STATUS: ACTIVE<span class="cursor">_</span>
  </div>

  <div class="cmdline">
    > <input
        id="cmd"
        autofocus
        inputmode="text"
        autocomplete="off"
        autocapitalize="off"
        spellcheck="false"
        aria-label="Command input"
      >
  </div>

  <div id="output" class="output"></div>

  <script>
    // --- Parallax (desktop only) ---
    (() => {
      const root = document.documentElement;
      const max = 18; // px: subtle parallax

      const isMobile = matchMedia("(max-width: 680px)").matches;
      const reduce = matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (isMobile || reduce) return;

      let tx = 0, ty = 0;
      let cx = 0, cy = 0;
      let raf = 0;

      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

      function onMove(e){
        const w = window.innerWidth || 1;
        const h = window.innerHeight || 1;
        const nx = (e.clientX / w) * 2 - 1; // -1..1
        const ny = (e.clientY / h) * 2 - 1; // -1..1
        tx = clamp(nx * max, -max, max);
        ty = clamp(ny * max, -max, max);
        if (!raf) raf = requestAnimationFrame(tick);
      }

      function tick(){
        raf = 0;
        cx += (tx - cx) * 0.08;
        cy += (ty - cy) * 0.08;
        root.style.setProperty("--mx", cx.toFixed(2) + "px");
        root.style.setProperty("--my", cy.toFixed(2) + "px");

        if (Math.abs(tx - cx) > 0.1 || Math.abs(ty - cy) > 0.1){
          raf = requestAnimationFrame(tick);
        }
      }

      window.addEventListener("mousemove", onMove, { passive: true });
    })();

    // --- Command console ---
    const input = document.getElementById("cmd");
    const output = document.getElementById("output");

    function focusCmd(){
      setTimeout(() => { try{ input.focus(); }catch(e){} }, 0);
    }

    function respond(text){
      output.textContent = "> " + text;
      focusCmd();
    }

    function respondMulti(lines){
      output.textContent = "> " + lines.join("\n> ");
      focusCmd();
    }

    function nav(node){
      const map = {
        world:   {msg:"ACCESSING WORLD NODE",    url:"world.html"},
        system:  {msg:"ACCESSING SYSTEM NODE",   url:"mechanics.html"},
        subjects:{msg:"ACCESSING SUBJECTS NODE", url:"subjects.html"},
        archive: {msg:"ACCESSING ARCHIVE NODE",  url:"archive.html"},
        state:   {msg:"ACCESSING STATE MONITOR", url:"state.html"}
      };
      return map[node] || null;
    }

    function restricted(cmd){
      if(cmd === "help"){
        respondMulti([
          "LIMITED PROTOCOL AVAILABLE",
          "NAV: world | system | subjects | archive",
          "QUERY: subjects:list | subject <key>",
          "UTILITY: clear"
        ]);
        return "__handled__";
      }

      if(cmd === "override"){
        respondMulti([
          "OVERRIDE REJECTED",
          "AUDIT LOG ENTRY CREATED",
          "DEVIATION FLAGGED"
        ]);
        return "__handled__";
      }

      if(cmd === "exit") return "NO EXIT PARAMETERS FOUND";
      return null;
    }

    const SUBJECTS = {
      alex:   {id:"S-001", status:"ACTIVE",   access:"LIMITED"},
      kiwi:   {id:"S-003", status:"ACTIVE",   access:"LIMITED"},
      french: {id:"S-004", status:"ACTIVE",   access:"LIMITED"},
      mentor: {id:"S-002", status:"REDACTED", access:"DENIED"}
    };

    const OBSERVE = {
      alex:   "OBSERVATION: ACTIVE / CHANNELS: MULTIPLE",
      kiwi:   "OBSERVATION: ACTIVE / CHANNELS: LIMITED",
      french: "OBSERVATION: ACTIVE / CHANNELS: LIMITED",
      mentor: "OBSERVATION: DISALLOWED / REQUEST LOGGED"
    };

    function subjectLookup(key){
      const k = (key || "").toLowerCase().trim();
      const rec = SUBJECTS[k];
      if(!rec) return null;

      if(k === "mentor"){
        return [
          "RECORD FOUND",
          "SUBJECT: MENTOR",
          "ID: " + rec.id,
          "STATUS: " + rec.status,
          "ACCESS: " + rec.access,
          "DETAILS: [REDACTED]"
        ];
      }

      return [
        "RECORD FOUND",
        "SUBJECT: " + k.toUpperCase(),
        "ID: " + rec.id,
        "STATUS: " + rec.status,
        "ACCESS: " + rec.access
      ];
    }

    input.addEventListener("keydown", (e) => {
      if(e.key !== "Enter") return;

      const raw = input.value.trim();
      const value = raw.toLowerCase();
      input.value = "";

      if(!value){
        respond("AWAITING INPUT");
        return;
      }

      if(value === "clear"){
        output.textContent = "";
        focusCmd();
        return;
      }

      const r = restricted(value);
      if(r){
        if(r !== "__handled__") respond(r);
        return;
      }

      if(value === "drift"){
        respondMulti([
          "DRIFT STATUS",
          "LEVEL: WITHIN TOLERANCE",
          "OBSERVABILITY: LIMITED",
          "DISCLOSURE: NOT REQUIRED"
        ]);
        return;
      }

      if(value === "observe"){
        respondMulti([
          "OBSERVATION PROTOCOL",
          "FORMAT: observe <subject>",
          "DISCLOSURE: MINIMAL"
        ]);
        return;
      }

      if(value.startsWith("observe ")){
        const key = value.slice("observe ".length).trim();
        respond(OBSERVE[key] || "OBSERVATION: NO TARGET FOUND");
        return;
      }

      if(value === "subjects:list" || value === "subject:list"){
        respondMulti([
          "SUBJECT INDEX AVAILABLE",
          "QUERY FORMAT: subject <key>",
          "KNOWN KEYS: alex, mentor, kiwi, french"
        ]);
        return;
      }

      if(value.startsWith("subject ")){
        const key = value.slice("subject ".length).trim();
        if(!key){
          respond("SUBJECT KEY REQUIRED");
          return;
        }
        const lines = subjectLookup(key);
        if(lines) respondMulti(lines);
        else respond("NO RECORD FOUND");
        return;
      }

      const res = nav(value);
      if(res){
        respond(res.msg);
        setTimeout(() => { window.location.href = res.url; }, 400);
        return;
      }

      respond("COMMAND NOT RECOGNIZED");
    });

    window.addEventListener("load", focusCmd);
  </script>

</body>
</html>