<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>System Interface</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="style.css">

  <style>
    :root{
      --banner: url("images/png/hl-system-layered-banner-01.png");
      --bg-dim-alpha: 0.04;

      /* Desktop 3D parallax state (updated by JS) */
      --rx: 0deg;
      --ry: 0deg;
      --tx: 0px;
      --ty: 0px;

      /* UI state */
      --ui-dim-mult: 1;
    }

    /* Disable global banner layers from style.css on this page */
    body::before,
    body::after{
      display:none !important;
      content:none !important;
    }

    html, body { height:100%; }

    body{
      margin:0;
      min-height:100svh;
      overflow:hidden;
    }

    /* --- background stage (DESKTOP/TABLET) --- */
    .bg{
      position:fixed;
      inset:0;
      z-index:-2;
      overflow:hidden;
      background:#0b0b0b;

      perspective: 900px;
      transform-style: preserve-3d;
    }

    .bg-scene{
      position:absolute;
      inset:-4vh -4vw;
      transform-style: preserve-3d;
      will-change: transform;

      transform:
        translate3d(var(--tx), var(--ty), 0)
        rotateX(var(--rx))
        rotateY(var(--ry));
    }

    .bg-layer{
      position:absolute;
      inset:0;

      background-image: var(--banner);
      background-repeat:no-repeat;
      background-position:center center;
      background-size:cover;

      will-change: transform;
      transform-style: preserve-3d;

      backface-visibility:hidden;
      -webkit-backface-visibility:hidden;
      transform: translateZ(0);
    }

    /* Desktop/iPad depth */
    .bg-layer-1{ opacity:1;    transform: translateZ(-60px) scale(1.02); }
    .bg-layer-2{ opacity:0.45; transform: translateZ(-20px) scale(1.01); }
    .bg-layer-3{ opacity:0.22; transform: translateZ( 20px) scale(1.00); }

    .bg-fx{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0.10;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.05) 0px,
          rgba(255,255,255,0.05) 1px,
          rgba(0,0,0,0) 3px,
          rgba(0,0,0,0) 6px
        );
      transform: translateZ(80px);
      transition: opacity 220ms ease;
    }
    .bg-fx.pulse{ opacity:0.16; }

    .bg-dim{
      position:absolute;
      inset:0;
      pointer-events:none;
      background: rgba(0,0,0,var(--bg-dim-alpha));
      transform: translateZ(90px);
    }

    /* Tablet defaults */
    @media (max-width: 980px){
      :root{ --bg-dim-alpha: 0.06; }
      .bg-layer{ background-size:cover; background-position:center center; }
    }

    /* =========================================================
       MOBILE FIX (ALL smartphones):
       - disable 3D completely
       - single background layer only
       - slow drift via background-position (NO transforms, NO rAF)
       ========================================================= */
    html.mobile .bg{
      perspective:none !important;
      transform-style: flat !important;
    }
    html.mobile .bg-scene{
      inset:0 !important;
      transform:none !important;
      will-change:auto !important;
    }

    html.mobile .bg-layer{
      transform:none !important;
      will-change:auto !important;
      backface-visibility: visible !important;
      -webkit-backface-visibility: visible !important;

      /* drift without transforms */
      animation: driftBg 26s ease-in-out infinite alternate;
      background-position: 50% 50%;
    }

    html.mobile .bg-layer-2,
    html.mobile .bg-layer-3{
      display:none !important;
    }

    html.mobile .bg-fx,
    html.mobile .bg-dim{
      transform:none !important;
    }

    @keyframes driftBg{
      0%   { background-position: 48% 52%; }
      50%  { background-position: 52% 48%; }
      100% { background-position: 50% 54%; }
    }

    @media (prefers-reduced-motion: reduce){
      html.mobile .bg-layer{ animation:none !important; }
      .bg-scene{ transform:none !important; }
    }

    /* --- page-specific --- */
    .backwrap{
      margin-bottom:10px;
    }
    .backbtn{
      font-size:14px;
      color:var(--dim);
      text-decoration:none;
      display:inline-block;
      padding:2px 0;
      cursor:pointer;
    }
    .backbtn:hover{ color:var(--fg); }

    .title{
      font-size:18px;
      margin-bottom:18px;
    }

    .menu .node{
      display:block;
      font-size:16px;
      line-height:30px;
    }

    .menu .node--service{
      margin-top:10px;
      font-size:14px;
      color:var(--dim);
    }
    .menu .node--service::before{ color:var(--dim); }
    .menu .node--service:hover{ color:var(--fg); }

    /* Lockdown: menu becomes non-interactive (command-only) */
    html.lock .menu{
      pointer-events:none;
      opacity:0.65;
      filter: saturate(0.9);
    }

    .status{
      margin-top:26px;
      font-size:13px;
      user-select:none;
    }

    /* “Heartbeat” cursor (irregular CRT-like) */
    .cursor{
      display:inline-block;
      margin-left:2px;
      animation: cursorHeart 2.8s steps(1,end) infinite;
    }
    @keyframes cursorHeart{
      0% { opacity:1; }
      7% { opacity:0; }
      10%{ opacity:1; }
      18%{ opacity:0; }
      22%{ opacity:1; }
      61%{ opacity:1; }
      66%{ opacity:0; }
      70%{ opacity:1; }
      100%{ opacity:1; }
    }

    /* Packet marker without using '|' */
    .pkt{
      display:inline-block;
      width:10px;
      height:14px;
      margin-left:6px;
      position:relative;
      vertical-align:-2px;
      opacity:0.75;
    }
    .pkt::before{
      content:"";
      position:absolute;
      left:50%;
      top:0;
      width:1px;
      height:100%;
      background: currentColor;
      transform: translateX(-50%);
      animation: pktBlink 6.8s steps(1,end) infinite;
    }
    @keyframes pktBlink{
      0%   { opacity:0.15; }
      70%  { opacity:0.15; }
      73%  { opacity:0.95; }
      76%  { opacity:0.15; }
      100% { opacity:0.15; }
    }

    .cmdline{
      margin-top:18px;
      font-size:14px;
      position:relative;
    }

    #cmd{
      background:none;
      border:none;
      outline:none;
      color:var(--fg);
      font-family:"JetBrains Mono", monospace;
      font-size:14px;
      width:min(520px, 84vw);
    }

    /* Inline hint (no extra blocks) */
    .hint{
      position:absolute;
      left:18px;
      top:0;
      color:var(--dim);
      opacity:0.55;
      pointer-events:none;
      white-space:nowrap;
      font-size:14px;
    }
    .hint.hidden{ display:none; }

    /* ACCESS line (always visible label) */
    .subline{
      margin-top:14px;
      font-size:14px;
      position:relative;
      opacity:0.92;
    }
    .sublabel{
      font-size:12px;
      letter-spacing:0.08em;
      color:var(--dim);
      opacity:0.85;
      margin-bottom:6px;
      text-transform:uppercase;
    }

    /* IMPORTANT MOBILE CLICK FIX */
    #access{
      background:none;
      border:none;
      outline:none;
      color:var(--fg);
      font-family:"JetBrains Mono", monospace;
      font-size:14px;
      width:min(520px, 84vw);

      pointer-events:auto;
      cursor:text;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      caret-color: var(--fg);
    }
    #access::placeholder{
      color:var(--dim);
      opacity:0.65;
    }

    .output{
      margin-top:18px;
      font-size:14px;
      color:var(--dim);
      min-height:18px;
      white-space:pre-line;
    }

    /* grep-like highlight (subtle, monochrome) */
    .hl{
      color:var(--fg);
      opacity:0.92;
      text-decoration: underline;
      text-decoration-thickness: 1px;
      text-underline-offset: 3px;
    }

    .status .meta{
      color:var(--dim);
      opacity: calc(0.85 * var(--ui-dim-mult));
      margin-top:6px;
    }
  </style>
</head>

<body>

  <!-- layered background -->
  <div class="bg" aria-hidden="true">
    <div class="bg-scene" id="bgScene">
      <div class="bg-layer bg-layer-1"></div>
      <div class="bg-layer bg-layer-2"></div>
      <div class="bg-layer bg-layer-3"></div>
      <div class="bg-fx" id="bgFx"></div>
      <div class="bg-dim"></div>
    </div>
  </div>

  <!-- BACK (top) -->
  <div class="backwrap">
    <a class="backbtn" href="#" id="backBtn">← BACK</a>
  </div>

  <div class="title">HUMAN LIMIT — SYSTEM INTERFACE</div>

  <nav class="menu" aria-label="System nodes" id="menu">
    <a class="node" href="world.html">WORLD</a>
    <a class="node" href="mechanics.html">SYSTEM</a>
    <a class="node" href="subjects.html">SUBJECTS</a>
    <a class="node" href="archive.html">ARCHIVE</a>
    <a class="node node--service" href="state.html">STATE MONITOR</a>
  </nav>

  <div class="status dim" id="status">
    ACCESS STATUS: ACTIVE<span class="cursor">_</span><span class="pkt" aria-hidden="true"></span>
    <div class="meta" id="sessionMeta"></div>
  </div>

  <div class="cmdline">
    &gt; <input
        id="cmd"
        autofocus
        inputmode="text"
        autocomplete="off"
        autocapitalize="off"
        spellcheck="false"
        aria-label="Command input"
      >
    <span id="hint" class="hint">type: world, subjects, search alex, map, trace world</span>
  </div>

  <!-- ACCESS CODE -->
  <div class="subline" aria-label="Access line">
    <div class="sublabel">ENTER YOUR ACCESS CODE</div>
    &gt; <input
        id="access"
        inputmode="numeric"
        autocomplete="one-time-code"
        autocapitalize="off"
        spellcheck="false"
        maxlength="6"
        placeholder="6 digits"
        aria-label="Access code input"
      >
  </div>

  <div id="output" class="output"></div>

  <script>
    // =========================================================
    // 0) Platform mode: mobile => disable 3D (stable)
    // =========================================================
    (() => {
      const root = document.documentElement;
      const isMobile =
        matchMedia("(hover: none)").matches ||
        matchMedia("(pointer: coarse)").matches ||
        matchMedia("(max-width: 820px)").matches;

      if (isMobile) root.classList.add("mobile");
    })();

    // =========================================================
    // 1) Background motion:
    //    - MOBILE: CSS drift only (no JS)
    //    - DESKTOP: pointer 3D parallax
    //    - iPad/tablet (not mobile class): slow idle 3D drift
    // =========================================================
    (() => {
      const root = document.documentElement;
      if (root.classList.contains("mobile")) return;

      const reduce = matchMedia("(prefers-reduced-motion: reduce)").matches;
      if (reduce) return;

      const canHover = matchMedia("(hover: hover)").matches;

      // Desktop: pointer-driven 3D
      if (canHover){
        const MAX_ROT = 6;   // deg
        const MAX_MOV = 14;  // px

        let tx=0, ty=0, rx=0, ry=0;
        let cx=0, cy=0, crx=0, cry=0;
        let raf=0;

        function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
        function apply(){
          root.style.setProperty("--tx", cx.toFixed(2) + "px");
          root.style.setProperty("--ty", cy.toFixed(2) + "px");
          root.style.setProperty("--rx", crx.toFixed(2) + "deg");
          root.style.setProperty("--ry", cry.toFixed(2) + "deg");
        }
        function tick(){
          raf = 0;
          cx  += (tx  - cx)  * 0.08;
          cy  += (ty  - cy)  * 0.08;
          crx += (rx  - crx) * 0.08;
          cry += (ry  - cry) * 0.08;
          apply();

          if (
            Math.abs(tx-cx)  > 0.08 ||
            Math.abs(ty-cy)  > 0.08 ||
            Math.abs(rx-crx) > 0.05 ||
            Math.abs(ry-cry) > 0.05
          ){
            raf = requestAnimationFrame(tick);
          }
        }
        function schedule(){ if(!raf) raf = requestAnimationFrame(tick); }

        window.addEventListener("pointermove", (e) => {
          const w = window.innerWidth || 1;
          const h = window.innerHeight || 1;
          const nx = (e.clientX / w) * 2 - 1;
          const ny = (e.clientY / h) * 2 - 1;

          tx = clamp(nx * MAX_MOV, -MAX_MOV, MAX_MOV);
          ty = clamp(ny * MAX_MOV, -MAX_MOV, MAX_MOV);
          ry = clamp(nx * MAX_ROT, -MAX_ROT, MAX_ROT);
          rx = clamp(-ny * MAX_ROT, -MAX_ROT, MAX_ROT);

          schedule();
        }, { passive:true });

        return;
      }

      // Tablet/iPad: slow idle drift (3D allowed)
      let t0 = performance.now();
      function idle(now){
        const t = (now - t0) / 1000;

        const ry = Math.sin(t * 0.14) * 2.2;   // deg
        const rx = Math.cos(t * 0.11) * 1.6;   // deg
        const tx = Math.sin(t * 0.12) * 6.0;   // px
        const ty = Math.cos(t * 0.10) * 4.0;   // px

        root.style.setProperty("--ry", ry.toFixed(2) + "deg");
        root.style.setProperty("--rx", rx.toFixed(2) + "deg");
        root.style.setProperty("--tx", tx.toFixed(2) + "px");
        root.style.setProperty("--ty", ty.toFixed(2) + "px");

        requestAnimationFrame(idle);
      }
      requestAnimationFrame(idle);
    })();

    // =========================================================
    // 2) Command console + internal search + fuzzy + UX + ACCESS
    // =========================================================
    const root = document.documentElement;
    const input = document.getElementById("cmd");
    const access = document.getElementById("access");
    const output = document.getElementById("output");
    const hint = document.getElementById("hint");
    const bgFx = document.getElementById("bgFx");
    const sessionMeta = document.getElementById("sessionMeta");
    const backBtn = document.getElementById("backBtn");

    // ----- BACK button -----
    // Always go to ENTRY (index.html). No history.
    backBtn.addEventListener("click", (e) => {
      e.preventDefault();
      window.location.href = "index.html";
    });

    // ----- session keys -----
    const SESSION_KEY = "hl_session_state_v2";
    const ERR_KEY = "hl_session_err_v2";
    const CMD_COUNT_KEY = "hl_session_cmd_count_v2";
    const LOCK_KEY = "hl_lock_v2";
    const ACCESS_LEVEL_KEY = "hl_access_level_v1";

    // access levels
    const LEVELS = [
      { n:0, name:"GREEN", label:"GREEN LINE" },
      { n:1, name:"BLUE",  label:"BLUE LINE"  },
      { n:2, name:"AMBER", label:"AMBER LINE" },
      { n:3, name:"BLACK", label:"BLACK LINE" }
    ];

    // Codes -> level
    const ACCESS_CODES = {
      "250201": 1, "298508": 1, "290713": 1,   // BLUE
      "685869": 2, "676906": 2, "663209": 2,   // AMBER
      "976114": 3, "974666": 3, "934679": 3    // BLACK
    };

    // Level -> destination folder
    const CLEARANCE_ROUTE = {
      1: "clearance-blue/",
      2: "clearance-amber/",
      3: "clearance-black/"
    };

    function getNum(k, def=0){
      const v = parseInt(sessionStorage.getItem(k) || "", 10);
      return Number.isFinite(v) ? v : def;
    }
    function setNum(k, v){ sessionStorage.setItem(k, String(v)); }

    function getSessionState(){ return sessionStorage.getItem(SESSION_KEY) || "INIT"; }
    function setSessionState(s){
      sessionStorage.setItem(SESSION_KEY, s);
      renderSessionMeta();
    }
    function incCmd(){
      const n = getNum(CMD_COUNT_KEY, 0) + 1;
      setNum(CMD_COUNT_KEY, n);
      if (n >= 2 && getSessionState() === "INIT") setSessionState("ACTIVE");
    }
    function incErr(){
      const n = getNum(ERR_KEY, 0) + 1;
      setNum(ERR_KEY, n);
      if (n >= 2) setSessionState("DEGRADED");
      return n;
    }

    function isLocked(){ return sessionStorage.getItem(LOCK_KEY) === "1"; }
    function setLocked(on){
      sessionStorage.setItem(LOCK_KEY, on ? "1" : "0");
      root.classList.toggle("lock", on);
      root.style.setProperty("--ui-dim-mult", on ? "1.08" : "1");
      renderSessionMeta();
    }

    function getAccessLevel(){
      const v = parseInt(sessionStorage.getItem(ACCESS_LEVEL_KEY) || "0", 10);
      return Number.isFinite(v) ? Math.max(0, Math.min(3, v)) : 0;
    }
    function setAccessLevel(n){
      const lvl = Math.max(0, Math.min(3, n));
      sessionStorage.setItem(ACCESS_LEVEL_KEY, String(lvl));
      renderSessionMeta();
    }
    function levelInfo(n){
      return LEVELS.find(x => x.n === n) || LEVELS[0];
    }

    function renderSessionMeta(){
      const s = getSessionState();
      const err = getNum(ERR_KEY, 0);
      const cmdc = getNum(CMD_COUNT_KEY, 0);
      const lock = isLocked() ? "LOCKED" : "OPEN";
      const a = getAccessLevel();
      const aInfo = levelInfo(a);
      sessionMeta.textContent =
        `SESSION: ${s}  MODE: ${lock}  CLEARANCE: ${aInfo.name}  COMMANDS: ${cmdc}  ERRORS: ${err}`;
    }

    renderSessionMeta();
    setLocked(isLocked());
    setAccessLevel(getAccessLevel());

    // ----- helpers -----
    function focusCmd(){
      setTimeout(() => { try{ input.focus(); }catch(e){} }, 0);
    }
    function focusAccess(){
      setTimeout(() => { try{ access.focus(); }catch(e){} }, 0);
    }

    function pulseFx(){
      if (!bgFx) return;
      bgFx.classList.add("pulse");
      setTimeout(() => bgFx.classList.remove("pulse"), 900);
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function escapeRegExp(s){
      return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function renderLines(lines, highlightTerm){
      const term = (highlightTerm || "").trim();
      const out = lines.map(line => {
        let safe = escapeHtml(line);
        if (term && term.length >= 2){
          const re = new RegExp(escapeRegExp(term), "i");
          safe = safe.replace(re, (m) => `<span class="hl">${escapeHtml(m)}</span>`);
        }
        return `&gt; ${safe}`;
      }).join("<br>");
      output.innerHTML = out;
      focusCmd();
    }

    function respond(text){ renderLines([text], ""); }
    function respondMulti(lines, highlightTerm){ renderLines(lines, highlightTerm || ""); }

    // ----- Hint behavior (cmd only) -----
    function updateHint(){
      const hasText = (input.value || "").length > 0;
      hint.classList.toggle("hidden", hasText || document.activeElement !== input);
    }
    input.addEventListener("focus", updateHint);
    input.addEventListener("blur", updateHint);
    input.addEventListener("input", updateHint);

    // ----- command history -----
    const history = [];
    let histPos = -1;

    function pushHistory(cmd){
      const c = (cmd || "").trim();
      if (!c) return;
      if (history.length && history[history.length - 1] === c) return;
      history.push(c);
      if (history.length > 50) history.shift();
      histPos = history.length;
    }
    function histUp(){
      if (!history.length) return;
      histPos = Math.max(0, histPos - 1);
      input.value = history[histPos] || "";
      updateHint();
    }
    function histDown(){
      if (!history.length) return;
      histPos = Math.min(history.length, histPos + 1);
      input.value = history[histPos] || "";
      updateHint();
    }

    // ----- navigation + index (with access gating) -----
    function nav(node){
      const map = {
        world:     {msg:"ACCESSING WORLD NODE",      url:"world.html"},
        system:    {msg:"ACCESSING SYSTEM NODE",     url:"mechanics.html"},
        mechanics: {msg:"ACCESSING SYSTEM NODE",     url:"mechanics.html"},
        subjects:  {msg:"ACCESSING SUBJECTS NODE",   url:"subjects.html"},
        archive:   {msg:"ACCESSING ARCHIVE NODE",    url:"archive.html"},
        state:     {msg:"ACCESSING STATE MONITOR",   url:"state.html"},
        monitor:   {msg:"ACCESSING STATE MONITOR",   url:"state.html"},
        entry:     {msg:"RETURNING TO ENTRY POINT",  url:"index.html"},
        interface: {msg:"ACCESSING INTERFACE NODE",  url:"interface.html"}
      };
      return map[node] || null;
    }

    // minLevel: 0 GREEN, 1 BLUE, 2 AMBER, 3 BLACK
    const INDEX = [
      { key:"world",     title:"WORLD",     url:"world.html",          tags:["map","regions","grid","tension","global"], minLevel:0 },

      { key:"system",    title:"SYSTEM",    url:"mechanics.html",      tags:["rules","protocol","mechanics","laws","core"], minLevel:0 },
      { key:"mechanics", title:"MECHANICS", url:"mechanics.html",      tags:["system","logic","structure"], minLevel:0 },

      { key:"subjects",  title:"SUBJECTS",  url:"subjects.html",       tags:["profiles","entities","index","persons"], minLevel:0 },
      { key:"alex",      title:"ALEX",      url:"subject-alex.html",   tags:["subject","profile","s-001"], minLevel:0 },
      { key:"kiwi",      title:"KIWI",      url:"subject-kiwi.html",   tags:["subject","profile","s-003"], minLevel:0 },
      { key:"mentor",    title:"MENTOR",    url:"subject-mentor.html", tags:["subject","profile","redacted"], minLevel:1 }, /* gated at BLUE */

      { key:"archive",   title:"ARCHIVE",   url:"archive.html",        tags:["logs","records","history","files"], minLevel:0 },
      { key:"state",     title:"STATE",     url:"state.html",          tags:["monitor","status","telemetry","system state"], minLevel:0 },

      { key:"entry",     title:"ENTRY",     url:"index.html",          tags:["start","gateway","root"], minLevel:0 },
      { key:"interface", title:"INTERFACE", url:"interface.html",      tags:["ui","layer","transition"], minLevel:0 }
    ];

    function visibleIndex(){
      const lvl = getAccessLevel();
      return INDEX.filter(x => (x.minLevel || 0) <= lvl);
    }

    // ----- tokens for autocomplete (dynamic by access) -----
    function tokens(){
      const lvl = getAccessLevel();
      const base = [
        "help","clear","search","open","map","trace","lock","unlock","drift",
        "world","system","mechanics","subjects","archive","state","monitor","entry","interface",
        "access","access:clear","back","return","subject"
      ];
      const extra = ["alex","kiwi"];
      if (lvl >= 1) extra.push("mentor");
      return base.concat(extra);
    }

    function completeToken(text){
      const raw = text || "";
      const parts = raw.split(/\s+/);
      const last = parts[parts.length - 1] || "";
      const head = parts.slice(0, -1).join(" ");

      // Special: "subject <key>"
      if (parts[0] === "subject" && parts.length === 2){
        const k = (last || "").toLowerCase();
        const keys = ["alex","kiwi"];
        if (getAccessLevel() >= 1) keys.push("mentor");
        const matches = keys.filter(x => x.startsWith(k));
        if (matches.length === 1) return "subject " + matches[0];
      }

      const q = last.toLowerCase();
      if (!q) return null;

      const tks = tokens();
      const matches = tks.filter(t => t.startsWith(q));
      if (matches.length !== 1) return null;

      const completed = matches[0];
      return (head ? (head + " ") : "") + completed;
    }

    // ----- search scoring -----
    let LAST_RESULTS = [];

    function scoreHit(q, item){
      const s = q.toLowerCase();
      const key = item.key.toLowerCase();
      const title = item.title.toLowerCase();
      const tags = (item.tags || []).join(" ").toLowerCase();

      if (key === s) return 100;
      if (title === s) return 90;
      if (key.startsWith(s)) return 70;
      if (title.includes(s)) return 55;
      if (tags.includes(s)) return 35;
      return 0;
    }

    function doSearch(query){
      const q = (query || "").trim();
      if (!q) return [];

      const pool = visibleIndex();
      return pool
        .map(it => ({ it, sc: scoreHit(q, it) }))
        .filter(x => x.sc > 0)
        .sort((a,b) => b.sc - a.sc)
        .map(x => x.it)
        .slice(0, 6);
    }

    // ----- fuzzy (Levenshtein) on VISIBLE items only -----
    function levenshtein(a, b, maxDist){
      a = (a || "").toLowerCase();
      b = (b || "").toLowerCase();
      const al = a.length, bl = b.length;

      if (Math.abs(al - bl) > maxDist) return maxDist + 1;
      if (al === 0) return bl;
      if (bl === 0) return al;

      const v0 = new Array(bl + 1);
      const v1 = new Array(bl + 1);
      for (let j = 0; j <= bl; j++) v0[j] = j;

      for (let i = 0; i < al; i++){
        v1[0] = i + 1;
        let rowMin = v1[0];

        for (let j = 0; j < bl; j++){
          const cost = a[i] === b[j] ? 0 : 1;
          const del = v0[j + 1] + 1;
          const ins = v1[j] + 1;
          const sub = v0[j] + cost;
          const val = Math.min(del, ins, sub);
          v1[j + 1] = val;
          if (val < rowMin) rowMin = val;
        }
        if (rowMin > maxDist) return maxDist + 1;
        for (let j = 0; j <= bl; j++) v0[j] = v1[j];
      }
      return v0[bl];
    }

    function fuzzySuggest(query){
      const q = (query || "").trim().toLowerCase();
      if (!q || q.length < 2) return [];

      const maxDist = q.length <= 4 ? 1 : 2;
      const pool = visibleIndex();

      return pool.map(it => {
        const k = it.key.toLowerCase();
        const t = it.title.toLowerCase();
        const dk = levenshtein(q, k, maxDist);
        const dt = levenshtein(q, t, maxDist);
        const d = Math.min(dk, dt);
        return { it, d };
      })
      .filter(x => x.d <= maxDist)
      .sort((a,b) => a.d - b.d)
      .slice(0, 5);
    }

    function confidentSuggestion(sug){
      if (!sug || !sug.length) return null;
      if (sug.length === 1) return sug[0];
      if (sug[0].d === 0) return sug[0];
      if (sug[0].d <= 1 && sug[1].d >= 3) return sug[0];
      return null;
    }

    // ----- map / trace (no vertical bars) -----
    function siteMapLines(){
      const lvl = getAccessLevel();
      const base = [
        "ROOT",
        "  WORLD",
        "  SYSTEM",
        "    MECHANICS",
        "  SUBJECTS",
        "    ALEX",
        "    KIWI",
        "  ARCHIVE",
        "  STATE",
        "  INTERFACE",
        "  ENTRY"
      ];
      if (lvl >= 1) base.splice(7, 0, "    MENTOR");
      return base;
    }

    function traceLines(targetKey){
      const key = (targetKey || "").toLowerCase().trim();
      const pool = visibleIndex();
      const hit = pool.find(x => x.key === key) || null;
      const n = nav(key) || hit;

      if (!n) return [
        "TRACE: NO TARGET FOUND",
        "FORMAT: trace <node>"
      ];

      const url = n.url || n.url;
      return [
        "TRACE ROUTE",
        "SYSTEM -> ROUTER",
        "ROUTE MATCH -> " + key.toUpperCase(),
        "TARGET URL -> " + url,
        "STATUS -> OK"
      ];
    }

    // ----- subject lookup with access-based disclosure -----
    function subjectLookup(key){
      const k = (key || "").toLowerCase().trim();
      const lvl = getAccessLevel();

      const known = ["alex","kiwi","mentor"];
      if (!known.includes(k)) return null;

      if (k === "mentor" && lvl < 1){
        return [
          "RECORD FOUND",
          "SUBJECT: MENTOR",
          "ACCESS: DENIED",
          "CLEARANCE REQUIRED: BLUE"
        ];
      }

      const base = [
        "RECORD FOUND",
        "SUBJECT: " + k.toUpperCase()
      ];

      if (k === "alex"){
        base.push("ID: S-001");
        base.push("STATUS: ACTIVE");
        base.push("ACCESS: " + (lvl >= 2 ? "CONTROLLED" : "LIMITED"));
        if (lvl >= 1) base.push("DISCLOSURE: PARTIAL");
        if (lvl >= 2) base.push("NOTES: [CLASSIFIED SEGMENT UNLOCKED]");
        if (lvl >= 3) base.push("FULL RECORD: [COMPLETE]");
        return base;
      }

      if (k === "kiwi"){
        base.push("ID: S-003");
        base.push("STATUS: ACTIVE");
        base.push("ACCESS: " + (lvl >= 1 ? "LIMITED" : "BASIC"));
        if (lvl >= 1) base.push("DISCLOSURE: EXPANDED");
        if (lvl >= 2) base.push("NOTES: [CLASSIFIED SEGMENT UNLOCKED]");
        if (lvl >= 3) base.push("FULL RECORD: [COMPLETE]");
        return base;
      }

      // mentor
      base.push("ID: S-002");
      base.push("STATUS: REDACTED");
      base.push("ACCESS: " + (lvl >= 3 ? "GRANTED" : (lvl >= 2 ? "CONTROLLED" : "LIMITED")));
      if (lvl === 1) base.push("DETAILS: [REDACTED]");
      if (lvl === 2) base.push("DETAILS: [PARTIAL REVEAL]");
      if (lvl >= 3) base.push("DETAILS: [FULL REVEAL]");
      return base;
    }

    // parsing + route preview
    function go(url, msg, meta){
      pulseFx();

      const lines = [];
      if (msg) lines.push(msg);
      if (meta && meta.length) lines.push(...meta);

      const parsing = [
        "PARSING...",
        "ROUTE RESOLUTION...",
        "LINK ESTABLISHED"
      ];

      respondMulti(lines.length ? lines : ["PARSING..."]);
      setTimeout(() => {
        respondMulti([...lines, ...parsing]);
        setTimeout(() => { window.location.href = url; }, 450);
      }, 280);
    }

    // =========================================================
    // ACCESS CODE (redirect to folders)
    // =========================================================
    function goToClearance(level){
      const dest = CLEARANCE_ROUTE[level];
      if (!dest) return;

      pulseFx();
      const info = levelInfo(level);

      respondMulti([
        "ACCESS GRANTED",
        "CLEARANCE: " + info.name,
        "ROUTE: /" + dest
      ]);

      // Small delay keeps terminal feel
      setTimeout(() => { window.location.href = dest; }, 420);
    }

    function handleAccessSubmit(){
      const raw = (access.value || "").trim();
      access.value = "";

      if (!raw){
        respond("ACCESS CODE: REQUIRED");
        focusAccess();
        return;
      }

      // keep digits only
      const code = raw.replace(/\D/g, "");
      if (code.length !== 6){
        incErr();
        respond("ACCESS CODE: INVALID FORMAT");
        focusAccess();
        return;
      }

      const lvl = ACCESS_CODES[code];
      if (typeof lvl !== "number"){
        const err = incErr();
        respond(err >= 3 ? "REDUNDANT INPUT DETECTED" : "ACCESS CODE: REJECTED");
        focusAccess();
        return;
      }

      setAccessLevel(lvl);
      goToClearance(lvl);
    }

    access.addEventListener("keydown", (e) => {
      if (e.key !== "Enter") return;
      e.preventDefault();
      handleAccessSubmit();
    });

    // Mobile reliability: tap the access line => focus input
    document.querySelector(".subline")?.addEventListener("click", (e) => {
      if (e.target && e.target.id === "access") return;
      focusAccess();
    }, { passive:true });

    // stop global click focus from stealing
    access.addEventListener("click", (e) => { e.stopPropagation(); });
    access.addEventListener("focus", () => { updateHint(); });

    // =========================================================
    // RESTRICTED / SPECIAL COMMANDS
    // =========================================================
    function restricted(cmd){
      if(cmd === "help"){
        respondMulti([
          "LIMITED PROTOCOL AVAILABLE",
          "NAV: world, system, subjects, archive, state, entry",
          "SEARCH: search <term>  OR  <term>",
          "OPEN: open <n>  (from last results)",
          "SUBJECT: subject <key>",
          "MAP: map",
          "TRACE: trace <node>",
          "MODE: lock, unlock",
          "ACCESS: access  OR  access:clear",
          "BACK: back",
          "UTILITY: clear",
          "INPUT: ArrowUp, ArrowDown history; Tab autocomplete"
        ]);
        return "__handled__";
      }

      if(cmd === "override"){
        respondMulti([
          "OVERRIDE REJECTED",
          "AUDIT LOG ENTRY CREATED",
          "DEVIATION FLAGGED"
        ]);
        return "__handled__";
      }

      if(cmd === "lock"){
        setLocked(true);
        respond("MODE: LOCKDOWN ENABLED");
        return "__handled__";
      }

      if(cmd === "unlock"){
        setLocked(false);
        respond("MODE: LOCKDOWN DISABLED");
        return "__handled__";
      }

      if(cmd === "map"){
        respondMulti(siteMapLines());
        return "__handled__";
      }

      if(cmd === "access"){
        const lvl = getAccessLevel();
        const info = levelInfo(lvl);
        respondMulti([
          "CLEARANCE STATUS",
          "LEVEL: " + info.name,
          "LINE: " + info.label
        ]);
        return "__handled__";
      }

      if(cmd === "access:clear"){
        setAccessLevel(0);
        respondMulti([
          "CLEARANCE RESET",
          "LEVEL: GREEN",
          "LINE: GREEN LINE"
        ]);
        return "__handled__";
      }

      if(cmd === "back" || cmd === "return"){
        window.location.href = "index.html";
        return "__handled__";
      }

      if(cmd === "clear"){
        output.textContent = "";
        focusCmd();
        return "__handled__";
      }

      if(cmd === "exit") return "NO EXIT PARAMETERS FOUND";
      return null;
    }

    // =========================================================
    // COMMAND LINE CORE
    // =========================================================
    input.addEventListener("keydown", (e) => {
      // history
      if (e.key === "ArrowUp"){
        e.preventDefault();
        histUp();
        return;
      }
      if (e.key === "ArrowDown"){
        e.preventDefault();
        histDown();
        return;
      }

      // Tab autocomplete
      if (e.key === "Tab"){
        const next = completeToken(input.value);
        if (next){
          e.preventDefault();
          input.value = next;
          updateHint();
        }
        return;
      }

      if (e.key !== "Enter") return;

      const raw = input.value.trim();
      const value = raw.toLowerCase();
      input.value = "";
      updateHint();

      if(!value){
        respond("AWAITING INPUT");
        return;
      }

      pushHistory(raw);
      incCmd();

      const r = restricted(value);
      if(r){
        if(r !== "__handled__") respond(r);
        return;
      }

      if(value === "drift"){
        respondMulti([
          "DRIFT STATUS",
          "LEVEL: WITHIN TOLERANCE",
          "OBSERVABILITY: LIMITED",
          "DISCLOSURE: NOT REQUIRED"
        ]);
        return;
      }

      if (value.startsWith("trace ")){
        const key = value.slice(6).trim();
        respondMulti(traceLines(key));
        return;
      }

      if (value.startsWith("subject ")){
        const key = value.slice(8).trim();
        if(!key){
          respond("SUBJECT KEY REQUIRED");
          return;
        }
        const lines = subjectLookup(key);
        if(lines) respondMulti(lines);
        else {
          const err = incErr();
          respond(err >= 3 ? "REDUNDANT INPUT DETECTED" : "NO RECORD FOUND");
        }
        return;
      }

      if (value.startsWith("open ")){
        const n = parseInt(value.slice(5).trim(), 10);
        if (!Number.isFinite(n) || n < 1 || n > LAST_RESULTS.length){
          const err = incErr();
          respond(err >= 3 ? "REDUNDANT INPUT DETECTED" : "OPEN: INVALID INDEX");
          return;
        }
        const hit = LAST_RESULTS[n-1];
        go(hit.url, "OPENING: " + hit.title, [
          "MATCH: " + hit.title + "  KEY: " + hit.key,
          "ROUTE: " + hit.url
        ]);
        return;
      }

      if (value.startsWith("search ")){
        const q = raw.slice(7).trim();
        const hits = doSearch(q);
        LAST_RESULTS = hits;

        if (!hits.length){
          const sug = fuzzySuggest(q);
          const best = confidentSuggestion(sug);

          if (!sug.length){
            const err = incErr();
            respond(err >= 3 ? "REDUNDANT INPUT DETECTED" : "SEARCH: NO RESULTS");
            return;
          }

          if (best){
            LAST_RESULTS = [best.it];
            go(best.it.url, "CORRECTED: " + best.it.title, [
              "MATCH: " + best.it.title + "  KEY: " + best.it.key,
              "ROUTE: " + best.it.url
            ]);
            return;
          }

          LAST_RESULTS = sug.map(x => x.it);
          respondMulti([
            "DID YOU MEAN:",
            ...sug.map((x,i) => `${i+1}) ${x.it.title}  [${x.it.key}]`),
            "TYPE: open <n>"
          ], q);
          return;
        }

        if (hits.length === 1){
          go(hits[0].url, "SEARCH HIT: " + hits[0].title, [
            "MATCH: " + hits[0].title + "  KEY: " + hits[0].key,
            "ROUTE: " + hits[0].url
          ]);
          return;
        }

        respondMulti([
          "SEARCH RESULTS:",
          ...hits.map((h,i) => `${i+1}) ${h.title}  [${h.key}]`),
          "TYPE: open <n>"
        ], q);
        return;
      }

      const res = nav(value);
      if(res){
        // if node exists but is gated in INDEX, enforce gating
        const idx = INDEX.find(x => x.key === value);
        if (idx && (idx.minLevel || 0) > getAccessLevel()){
          incErr();
          respondMulti([
            "ACCESS DENIED",
            "CLEARANCE REQUIRED: " + levelInfo(idx.minLevel || 0).name
          ]);
          return;
        }

        go(res.url, res.msg, [
          "MATCH: " + value.toUpperCase(),
          "ROUTE: " + res.url
        ]);
        return;
      }

      // implicit search
      {
        const hits = doSearch(raw);
        LAST_RESULTS = hits;

        if (hits.length === 1){
          go(hits[0].url, "SEARCH HIT: " + hits[0].title, [
            "MATCH: " + hits[0].title + "  KEY: " + hits[0].key,
            "ROUTE: " + hits[0].url
          ]);
          return;
        }

        if (hits.length > 1){
          respondMulti([
            "SEARCH RESULTS:",
            ...hits.map((h,i) => `${i+1}) ${h.title}  [${h.key}]`),
            "TYPE: open <n>"
          ], raw);
          return;
        }

        const sug = fuzzySuggest(raw);
        const best = confidentSuggestion(sug);

        if (sug.length){
          if (best){
            LAST_RESULTS = [best.it];
            go(best.it.url, "CORRECTED: " + best.it.title, [
              "MATCH: " + best.it.title + "  KEY: " + best.it.key,
              "ROUTE: " + best.it.url
            ]);
            return;
          }

          LAST_RESULTS = sug.map(x => x.it);
          respondMulti([
            "DID YOU MEAN:",
            ...sug.map((x,i) => `${i+1}) ${x.it.title}  [${x.it.key}]`),
            "TYPE: open <n>"
          ], raw);
          return;
        }
      }

      const err = incErr();
      respond(err >= 3 ? "REDUNDANT INPUT DETECTED" : "COMMAND NOT RECOGNIZED");
    });

    // focus + hint
    window.addEventListener("load", () => {
      focusCmd();
      updateHint();
    });

    // Keep terminal feel, but DO NOT steal focus from ACCESS input
    document.addEventListener("click", (e) => {
      const t = e.target;
      if (t && (t.id === "cmd" || t.id === "access")) return;
      if (document.activeElement === access) return;
      focusCmd();
    }, { passive:true });
  </script>

</body>
</html>